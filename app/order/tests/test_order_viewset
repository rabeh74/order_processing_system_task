from django.urls import reverse
from rest_framework.test import APITestCase, APIClient
from rest_framework import status
from django.contrib.auth import get_user_model
from order.models import Order, OrderItem, Product, PromoCode
from django.utils import timezone
from unittest.mock import patch


User = get_user_model()

class OrderViewSetTestCase(APITestCase):
    def setUp(self):
        self.client = APIClient()
        
        # Create a user for authentication
        self.user = User.objects.create_user(email='test@example.com', password='testpass123')
        self.client.force_authenticate(user=self.user)
        
        # Create test data
        self.product1 = Product.objects.create(name='Laptop', price=999.99, stock=10)
        self.product2 = Product.objects.create(name='Mouse', price=19.99, stock=50)
        
        self.promo_code = PromoCode.objects.create(
            coupon_code='SAVE10', coupon_name='Save $10', type='FIXED',
            fixed_amount=10.00, start_at=timezone.now(),
            ended_at=timezone.now() + timezone.timedelta(days=30),
            is_active=True, count=100
        )
        
        self.order = Order.objects.create(user=self.user, total_price=0, discount=0)
        OrderItem.objects.create(order=self.order, product=self.product1, quantity=1, price=self.product1.price)
        
        # URLs
        self.list_url = reverse('order-list')
        self.detail_url = reverse('order-detail', kwargs={'pk': self.order.pk})

    def test_get_queryset_authenticated(self):
        """Test that get_queryset returns only the authenticated user's orders"""
        other_user = User.objects.create_user(email='other@example.com', password='otherpass123')
        Order.objects.create(user=other_user, total_price=100.00, discount=0)
        
        response = self.client.get(self.list_url)
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data), 1)  # Only the authenticated user's order
        self.assertEqual(response.data[0]['id'], self.order.id)

    def test_get_queryset_unauthenticated(self):
        """Test that unauthenticated users are denied access"""
        self.client.force_authenticate(user=None)  # Remove authentication
        response = self.client.get(self.list_url)
        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)

    def test_create_order_success(self):
        """Test successful order creation with items and promo code"""
        data = {
            'items': [
                {'product_id': self.product1.id, 'quantity': 2},
                {'product_id': self.product2.id, 'quantity': 1}
            ],
            'promo_code': 'SAVE10'
        }
        response = self.client.post(self.list_url, data, format='json')
        
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertEqual(Order.objects.count(), 1)  
        order = Order.objects.get(id=response.data['id'])
        
        # Check price calculation
        expected_total_before_discount = (self.product1.price * 2) + (self.product2.price * 1)
        expected_discount = 10.00
        expected_total = expected_total_before_discount - expected_discount
        
        self.assertEqual(float(order.total_price), float(expected_total))
        self.assertEqual(float(order.discount), expected_discount)
        self.assertEqual(order.promo_code.coupon_code, 'SAVE10')
        self.assertEqual(order.items.count(), 2)
        
        # Check email task was called
        mock_email_task.assert_called_once_with(order.id)

    def test_create_order_invalid_data(self):
        """Test order creation with invalid data (e.g., missing items)"""
        data = {'promo_code': 'SAVE10'}  # No items
        response = self.client.post(self.list_url, data, format='json')
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertIn('items', response.data)

    def test_create_order_invalid_promo_code(self):
        """Test order creation with an invalid promo code"""
        data = {
            'items': [{'product_id': self.product1.id, 'quantity': 1}],
            'promo_code': 'INVALIDCODE'
        }
        response = self.client.post(self.list_url, data, format='json')
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertIn('promo_code', response.data)

    def test_update_order_full(self):
        """Test full update of an order (replacing items and promo code)"""
        data = {
            'items': [{'product_id': self.product2.id, 'quantity': 3}],
            'promo_code': 'SAVE10'
        }
        response = self.client.put(self.detail_url, data, format='json')
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        order = Order.objects.get(id=self.order.id)
        
        # Check updated items
        self.assertEqual(order.items.count(), 1)
        self.assertEqual(order.items.first().product, self.product2)
        self.assertEqual(order.items.first().quantity, 3)
        
        # Check price calculation
        expected_total_before_discount = self.product2.price * 3
        expected_discount = 10.00
        expected_total = expected_total_before_discount - expected_discount
        
        self.assertEqual(float(order.total_price), float(expected_total))
        self.assertEqual(float(order.discount), expected_discount)
        self.assertEqual(order.promo_code.coupon_code, 'SAVE10')

    def test_update_order_partial_items(self):
        """Test partial update of items without changing promo code"""
        data = {
            'items': [{'product_id': self.product2.id, 'quantity': 2}]
        }
        response = self.client.put(self.detail_url, data, format='json')
        
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        order = Order.objects.get(id=self.order.id)
        
        self.assertEqual(order.items.count(), 1)
        self.assertEqual(order.items.first().product, self.product2)
        self.assertEqual(order.items.first().quantity, 2)
        self.assertEqual(float(order.total_price), float(self.product2.price * 2))
        self.assertEqual(float(order.discount), 0)  # No promo code applied
        self.assertIsNone(order.promo_code)

    def test_update_order_invalid_promo_code(self):
        """Test update with an invalid promo code"""
        data = {
            'items': [{'product_id': self.product1.id, 'quantity': 1}],
            'promo_code': 'INVALIDCODE'
        }
        response = self.client.put(self.detail_url, data, format='json')
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertIn('promo_code', response.data)

    def test_retrieve_order(self):
        """Test retrieving an order"""
        response = self.client.get(self.detail_url)
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['id'], self.order.id)
        self.assertEqual(len(response.data['items']), 1)
        self.assertEqual(response.data['total_price'], str(self.product1.price))

    def test_list_orders(self):
        """Test listing all orders for the user"""
        Order.objects.create(user=self.user, total_price=50.00, discount=0)  # Second order
        response = self.client.get(self.list_url)
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data), 2)  # Two orders for the user

    def test_unauthorized_access(self):
        """Test that another user cannot access or update the order"""
        other_user = User.objects.create_user(email='other@example.com', password='otherpass123')
        self.client.force_authenticate(user=other_user)
        
        # Test retrieve
        response = self.client.get(self.detail_url)
        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)
        
        # Test update
        data = {'items': [{'product_id': self.product1.id, 'quantity': 1}]}
        response = self.client.put(self.detail_url, data, format='json')
        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)